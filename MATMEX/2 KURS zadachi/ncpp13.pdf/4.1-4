#include <iostream>
#include <algorithm>

using namespace std;

const int N = 4;

template<class K, class T>
struct BTNode;

template<class K, class T>
struct Item
{
	K key;
	T data;
	BTNode<K, T>* down;
	Item(K k, T d, BTNode<K, T>* dd = nullptr) : key(k), data(d), down(dd) {}
};

template<class K, class T>
struct BTNode
{
	int n;
	Item<K, T>* ar[N];
	BTNode(Item<K, T>* p0, Item<K, T>* p1 = nullptr, Item<K, T>* p2 = nullptr)
	{
		if (p1 == nullptr) n = 1;
		else
			if (p2 == nullptr) n = 2;
			else n = 3;
		ar[0] = p0;
		ar[1] = p1;
		ar[2] = p2;
	}
	void print(BTNode<K, T>* p)
	{
		for (int i = 0; i < p->n; i++)
			cout << p->ar[i]->key << " " << p->ar[i]->data << endl;
	}
};

template<class K, class T>
void DELETE(BTNode<K, T>*& p);
template<class K, class T>
void print_1(BTNode<K, T>* r, int offset = 0);
template<class K, class T>
BTNode<K, T>* search_1(int key, BTNode<K, T>* p);

template<class K, class T>
struct BTTree 
{
	BTNode<K, T>* root; 
	int height;

	BTTree(BTNode<K, T>* p) : root(p), height(0) {}
	void print() { print_1(root); }
	BTNode<K, T>* search(K k) { return search_1(k, root); }

	~BTTree() { DELETE(root); }
};

template<class K, class T>
void print_1(BTNode<K, T>* r, int offset)
{
	if (r == nullptr) return;
	for (int i = 0; i < r->n; i++) 
	{
		for (int j = 0; j < offset * 6; j++) cout << " ";
		cout << r->ar[i]->key << " " << r->ar[i]->data << " " << endl;
		print_1(r->ar[i]->down, offset + 1);
	}
}

template<class K, class T>
BTNode<K, T>* search_1(int key, BTNode<K, T>* p)
{
	if (p == nullptr) EXIT_FAILURE;
	if (p->ar[0]->key > key) EXIT_FAILURE;
	for (int i = 0; i < p->n; i++)
		if (p->ar[i]->key == key)
			if (p->ar[i]->down != nullptr) return search_1(key, p->ar[i]->down);
			else return p;
}

template<class K, class T>
void DELETE(BTNode<K, T>*& p)
{
	if (p == nullptr) return;
	for(int i = p->n - 1; i >= 0; i--)
	{
		DELETE(p->ar[i]->down);
		p->ar[i] = nullptr;
	}
	delete p;
}

//void correct_h_1(BTNode<K, T>*& p);
//void rotate_right_1(BTNode<K, T>*& p);
//void rotate_left_1(BTNode<K, T>*& p);
//void rebalance_1(BTNode<K, T>*& p);
//void correctm2_1(BTNode<K, T>*& p);
//void correct2_1(BTNode<K, T>*& p);
//void insert_1(int key, int data, BTNode<K, T>*& p);
//void del_root_noleft_1(BTNode<K, T>*& p);
//void del_root_noright_1(BTNode<K, T>*& p);
//void del_uzel_noleft_1(BTNode<K, T>*& p);
//void del_uzel_noright_1(BTNode<K, T>*& p);
//void del_1(int key, BTNode<K, T>*& p);
//
//struct BTTree<K, T>
//{
//	BTNode<K, T>* root;
//
//	BTTree<K, T>(BTNode<K, T>* r) : root(r) {}
//	void correct_h() { correct_h_1(root); }
//	void correct_h(BTNode<K, T>*& p) { correct_h_1(p); }
//	void rotate_right(BTNode<K, T>*& p) { rotate_right_1(p); }
//	void rotate_left(BTNode<K, T>*& p) { rotate_left_1(p); }
//	void correctm2(BTNode<K, T>*& p) { correctm2_1(p); } //левый большой поворот
//	void correct2(BTNode<K, T>*& p) { correct2_1(p); } //правый большой поворот
//	void rebalance(BTNode<K, T>*& p) { rebalance_1(p); }
//	void insert(int k, int d) { insert_1(k, d, root); }
//	void del_root_noleft() { del_root_noleft_1(root); }
//	void del_root_noright() { del_root_noright_1(root); }
//	void del_uzel_noleft(BTNode<K, T>*& p) { del_uzel_noleft_1(p); }
//	void del_uzel_noright(BTNode<K, T>*& p) { del_uzel_noright_1(p); }
//	void del(int k) { del_1(k, root); }
//};
//
//void correct_h_1(BTNode<K, T>*& p)
//{
//	if (p == nullptr) return;
//	correct_h_1(p->right);
//	correct_h_1(p->left);
//	int n = -1, m = -1;
//	if (p->right != nullptr) m = p->right->size;
//	if (p->left != nullptr) n = p->left->size;
//	p->size = max(m, n) + 1;
//}
//
//void rotate_right_1(BTNode<K, T>*& p)
//{
//	if (p->right == nullptr || p == nullptr) return;
//	BTNode<K, T>* tmp = p->father;
//	BTNode<K, T>* tmp1 = p;
//	BTNode<K, T>* tmp2 = p->right;
//	BTNode<K, T>* tmp3 = p->right->left;
//	p->right = tmp3;
//	if (p->right != nullptr) p->right->father = p;
//	if (p->father != nullptr)
//	{
//		if (p->father->left == p) p->father->left = tmp2;
//		else p->father->right = tmp2;
//		tmp2->father = p->father;
//	}
//	else tmp2->father = nullptr;
//	tmp2->left = tmp1;
//	tmp2->left->father = tmp2;
//	tmp2->father = tmp;
//}
//
//void rotate_left_1(BTNode<K, T>*& p)
//{
//	if (p->left == nullptr || p == nullptr) return;
//	BTNode<K, T>* tmp = p->father;
//	BTNode<K, T>* tmp1 = p;
//	BTNode<K, T>* tmp2 = p->left;
//	BTNode<K, T>* tmp3 = p->left->right;
//	p->left = tmp3;
//	if (p->left != nullptr) p->left->father = p;
//	if (p->father != nullptr)
//	{
//		if (p->father->left == p) p->father->left = tmp2;
//		else p->father->right = tmp2;
//		tmp2->father = p->father;
//	}
//	else tmp2->father = nullptr;
//	tmp2->right = tmp1;
//	tmp2->right->father = tmp2;
//	tmp2->father = tmp;
//}
//
//void correctm2_1(BTNode<K, T>*& p)
//{
//	if (p->left->right == nullptr)
//	{
//		rotate_left_1(p);
//		return;
//	}
//	if (p->left->left == nullptr)
//	{
//		rotate_right_1(p->left);
//		rotate_left_1(p);
//		return;
//	}
//	if (p->left->left->size < p->left->right->size)
//	{
//		rotate_right_1(p->left);
//		rotate_left_1(p);
//	}
//	else rotate_left_1(p);
//}
//
//void correct2_1(BTNode<K, T>*& p)
//{
//	if (p->right->left == nullptr)
//	{
//		rotate_right_1(p);
//		return;
//	}
//	if (p->right->right == nullptr)
//	{
//		rotate_left_1(p->right);
//		rotate_right_1(p);
//		return;
//	}
//	if (p->right->right->size < p->right->left->size)
//	{
//		rotate_left_1(p->right);
//		rotate_right_1(p);
//	}
//	else rotate_right_1(p);
//}
//
//void rebalance_1(BTNode<K, T>*& p)
//{
//	if (p == nullptr) return;
//	if (p->father != nullptr)
//	{
//		rebalance_1(p->father);
//		return;
//	}
//	rebalance_1(p->left);
//	rebalance_1(p->right);
//	if (p->defect_h() >= 2) correct2_1(p);
//	if (p->defect_h() <= -2) correctm2_1(p);
//	correct_h_1(p);
//	if (p->father != nullptr) p->father->correct_h();
//}
//
//void insert_2(int key, int data, BTNode<K, T>*& p)
//{
//	if (p->key == key) return;
//	if (p->key > key)
//		if (p->right == nullptr) p->right = new BTNode<K, T>(key, data, 0, p->right);
//		else insert_1(key, data, p->right);
//	else
//		if (p->left == nullptr) p->left = new BTNode<K, T>(key, data, 0, p->left);
//		else insert_1(key, data, p->left);
//}
//
//void insert_1(int k, int d, BTNode<K, T>*& p)
//{
//	insert_2(k, d, p);
//	rebalance_1(p);
//}
//
//void del_root_noleft_1(BTNode<K, T>*& p)
//{
//	if (p == nullptr) return;
//	if (p->right == nullptr)
//	{
//		BTNode<K, T>* tmp = p;
//		p = nullptr;
//		delete tmp;
//		return;
//	}
//	BTNode<K, T>* tmp = p;
//	BTNode<K, T>* tmp1 = p->right;
//	tmp1->father = nullptr;
//	p->right = nullptr;
//	p = tmp1;
//	delete tmp;
//	rebalance_1(p);
//}
//
//void del_root_noright_1(BTNode<K, T>*& p)
//{
//	if (p == nullptr) return;
//	if (p->left == nullptr)
//	{
//		BTNode<K, T>* tmp = p;
//		p = nullptr;
//		delete tmp;
//		return;
//	}
//	BTNode<K, T>* tmp = p;
//	BTNode<K, T>* tmp1 = p->left;
//	tmp1->father = nullptr;
//	p->left = nullptr;
//	p = tmp1;
//	delete tmp;
//	rebalance_1(p);
//}
//
//void del_uzel_noleft_1(BTNode<K, T>*& p)
//{
//	if (p == nullptr) return;
//	if (p->father == nullptr)
//	{
//		del_root_noleft_1(p);
//		return;
//	}
//	if (p->right == nullptr)
//	{
//		BTNode<K, T>* tmp = p;
//		p->father = nullptr;
//		delete tmp;
//		return;
//	}
//	BTNode<K, T>* tmp = p;
//	BTNode<K, T>* tmp1 = p->right;
//	p->right = nullptr;
//	tmp1->father = tmp->father;
//	if (p->father->left == p) p->father->left = tmp1;
//	else p->father->right = tmp1;
//	delete tmp;
//	rebalance_1(p);
//}
//
//void del_uzel_noright_1(BTNode<K, T>*& p)
//{
//	if (p == nullptr) return;
//	if (p->father == nullptr)
//	{
//		del_root_noright_1(p);
//		return;
//	}
//	if (p->left == nullptr)
//	{
//		BTNode<K, T>* tmp = p;
//		p->father = nullptr;
//		delete tmp;
//		return;
//	}
//	BTNode<K, T>* tmp = p;
//	BTNode<K, T>* tmp1 = p->left;
//	p->left = nullptr;
//	tmp1->father = tmp->father;
//	if (p->father->left == p) p->father->left = tmp1;
//	else p->father->right = tmp1;
//	delete tmp;
//	rebalance_1(p);
//}
//
//void del_2(int key, BTNode<K, T>*& p)
//{
//	if (p == nullptr) return;
//	if (p->key == key)
//	{
//		if (p->right == nullptr)
//		{
//			del_uzel_noright_1(p);
//			return;
//		}
//		if (p->left == nullptr)
//		{
//			del_uzel_noleft_1(p);
//			return;
//		}
//		p->key = p->left->key;
//		p->data = p->left->data;
//		del_2(p->key, p->left);
//		return;
//	}
//	if (p->key > key) del_2(key, p->right);
//	else del_2(key, p->left);
//}
//
//void del_1(int k, BTNode<K, T>*& p)
//{
//	del_1(k, p);
//	rebalance_1(p);
//}

int main()
{
	BTNode<int, int>* root = new BTNode<int, int>(new Item<int, int>(1, 1), new Item<int, int>(20, 20), new Item<int, int>(40, 40));

	root->ar[0]->down = new BTNode<int, int>(new Item<int, int>(1, 1), new Item<int, int>(7, 7));
	root->ar[1]->down = new BTNode<int, int>(new Item<int, int>(20, 20), new Item<int, int>(25, 25), new Item<int, int>(30, 30));
	root->ar[2]->down = new BTNode<int, int>(new Item<int, int>(40, 40), new Item<int, int>(51, 51));

	BTTree<int, int>* tree = new BTTree<int, int>(root);

	tree->print();
	cout << endl;

	root->print(tree->search(20));

	//system("pause");
	return 0;
}
