#include <iostream>
#include <algorithm>

using namespace std;

struct AVLNode
{
	int key;
	int data;
	int size;
	AVLNode* right;
	AVLNode* left;
	AVLNode* father;
	AVLNode(int k, int d, int s, AVLNode* f = nullptr, AVLNode* r = nullptr, AVLNode* l = nullptr) : key(k), data(d), size(s), father(f), right(r), left(l) {}
	void correct_h()
	{
		int n = -1, m = -1;
		if (right != nullptr) m = right->size;
		if (left != nullptr) n = left->size;
		size = max(m, n) + 1;
	}
	int defect_h()
	{
		int n = 0, m = 0;
		if (right != nullptr) m = right->size;
		if (left != nullptr) n = left->size;
		return m - n;
	}
	void print() { cout << key << " " << data << " " << size << " " << this << endl; }
};

void DELETE(AVLNode*& p);
void print_1(AVLNode* r, int offset = 0);
void correct_h_1(AVLNode*& p);

struct AVLTree
{
	AVLNode* root;

	AVLTree(AVLNode* r) : root(r) {}
	void print() { print_1(root); }
	void correct_h() { correct_h_1(root); }
	void rotate_right(AVLNode*& p)
	{
		if (p->right == nullptr || p == nullptr) return;
		AVLNode* tmp = p->father;
		AVLNode* tmp1 = p;
		AVLNode* tmp2 = p->right;
		AVLNode* tmp3 = p->right->left;

		p->right = tmp3;
		if(p->right != nullptr) p->right->father = p;
		if (p->father != nullptr)
		{
			if (p->father->left == p) p->father->left = tmp2;
			else p->father->right = tmp2;
			tmp2->father = p->father;
		}
		else tmp2->father = nullptr;
		tmp2->left = tmp1;
		tmp2->left->father = tmp2;
		tmp2->father = tmp;
	}
	void rotate_left(AVLNode*& p)
	{
		if (p->left == nullptr || p == nullptr) return;
		AVLNode* tmp = p->father;
		AVLNode* tmp1 = p;
		AVLNode* tmp2 = p->left;
		AVLNode* tmp3 = p->left->right;

		p->left = tmp3;
		if(p->left != nullptr) p->left->father = p;
		if (p->father != nullptr)
		{
			if (p->father->left == p) p->father->left = tmp2;
			else p->father->right = tmp2;
			tmp2->father = p->father;
		}
		else tmp2->father = nullptr;
		tmp2->right = tmp1;
		tmp2->right->father = tmp2;
		tmp2->father = tmp;
	}
	void correctm2(AVLNode*& p) //левый большой поворот
	{
		if (p->left->right == nullptr)
		{
			rotate_left(p);
			return;
		}
		if (p->left->left == nullptr)
		{
			rotate_right(p->left);
			rotate_left(p);
			return;
		}
		if (p->left->left->size < p->left->right->size)
		{
			rotate_right(p->left);
			rotate_left(p);
		}
		else rotate_left(p);
	}
	void correct2(AVLNode*& p) //правый большой поворот
	{
		if (p->right->left == nullptr)
		{
			rotate_right(p);
			return;
		}
		if (p->right->right == nullptr)
		{
			rotate_left(p->right);
			rotate_right(p);
			return;
		}
		if (p->right->right->size < p->right->left->size)
		{
			rotate_left(p->right);
			rotate_right(p);
		}
		else rotate_right(p);
	}

	~AVLTree() { DELETE(root); }
};

void print_1(AVLNode* r, int offset)
{
	if (r == nullptr) return;
	print_1(r->left, offset + 9);
	for (int i = 0; i < offset; i++) cout << " ";
	cout << r->key << " " << r->data << " " << r->size << endl;
	print_1(r->right, offset + 9);
}

void correct_h_1(AVLNode*& p)
{
	if (p == nullptr) return;
	correct_h_1(p->right);
	correct_h_1(p->left);
	int n = -1, m = -1;
	if (p->right != nullptr) m = p->right->size;
	if (p->left != nullptr) n = p->left->size;
	p->size = max(m, n) + 1;
}

void DELETE(AVLNode*& p)
{
	if (p->left != nullptr)
	{
		DELETE(p->left);
		p->left = nullptr;
	}
	if (p->right != nullptr)
	{
		DELETE(p->right);
		p->right = nullptr;
	}
	delete p;
}

int main()
{
	AVLNode* root = new AVLNode(5, 101, 0);
	root->right = new AVLNode(3, 111, 0, root);
	 root->right->left = new AVLNode(4, 411, 0, root->right);
	 root->right->right = new AVLNode(2, 611, 0, root->right);
	root->left = new AVLNode(6, 211, 0, root);
	 root->left->left = new AVLNode(11, 1111, 0, root->left);
	  root->left->left->right = new AVLNode(21, 3211, 0, root->left->left);
	  //root->left->left->right = new AVLNode(9, 4681, 0, root->left->left);
	AVLTree* tree = new AVLTree(root);

	tree->correct_h();
	tree->print();
	cout << endl;

	tree->correctm2(tree->root->left);
	tree->correct_h();
	tree->print();
	cout << endl;

	//system("pause");
	return 0;
}
