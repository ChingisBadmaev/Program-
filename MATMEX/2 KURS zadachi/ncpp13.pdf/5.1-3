#include <iostream>
#include <algorithm>

using namespace std;

template<class K, class T>
struct RBNode
{
	K key;
	T data;
	int color;
	RBNode* right;
	RBNode* left;
	RBNode* father;
	RBNode(K k, T d, int c, RBNode* f = nullptr, RBNode* r = nullptr, RBNode* l = nullptr) : key(k), data(d), color(c), father(f), right(r), left(l) {}
};

template<class K, class T>
void print_1(RBNode<K, T>* r, int offset = 0);
template<class K, class T>
RBNode<K, T>* search_1(K key, T data, RBNode<K, T>* p);

template<class K, class T>
void DELETE(RBNode<K, T>*& p);

template<class K, class T>
struct RBTree
{
	RBNode<K, T>* root;

	RBTree(RBNode<K, T>* p) : root(p) {}
	RBTree(RBTree<K, T>* r) : root(r->root) {}
	void print() { print_1(root); }
	RBNode<K, T>* search(K key, RBNode<K, T>* p) { search_1(key, p); }

	~RBTree() { DELETE(root); }
};

template<class K, class T>
void print_1(RBNode<K, T>* r, int offset)
{
	if (r == nullptr) return;
	print_1(r->left, offset + 7);
	for (int i = 0; i < offset; i++) cout << " ";
	cout << r->key << " " << r->data << " " << r->color << endl;
	print_1(r->right, offset + 7);
}

template<class K, class T>
RBNode<K, T>* search_1(K key, RBNode<K, T>* p)
{
	if (p == nullptr) return nullptr;
	if (key == p->key) return p;
	if (key > p->key) return search_1(key, p->left);
	return search_1(key, p->right);
}

template<class K, class T>
void DELETE(RBNode<K, T>*& p)
{
	if (p->left != nullptr)
	{
		DELETE(p->left);
		p->left = nullptr;
	}
	if (p->right != nullptr)
	{
		DELETE(p->right);
		p->right = nullptr;
	}
	delete p;
}

int main()
{
	RBNode<int, int>* root = new RBNode<int, int>(5, 5, 0);
	root->right = new RBNode<int, int>(3, 3, 0, root);
	    root->right->left = new RBNode<int, int>(4, 4, 0, root->right);
	    root->right->right = new RBNode<int, int>(2, 2, 0, root->right);
	root->left = new RBNode<int, int>(6, 6, 0, root);
	    root->left->left = new RBNode<int, int>(11, 11, 0, root->left);
	    root->left->left->left = new RBNode<int, int>(21, 21, 0, root->left->left);
        	root->left->left->right = new RBNode<int, int>(9, 9, 0, root->left->left);
	RBTree<int, int>* tree = new RBTree<int, int>(root);

	tree->print();
	cout << endl << endl;

	//system("pause");
	return 0;
}
