#include <iostream>
#include <clocale>
using namespace std;

struct reg_znak {
	int a;
	reg_znak(int aa) :a(aa) {}
};

struct Car { //базовый класс
	double x, y, dir;
	Car(double xx, double yy, double d) :x(xx), y(yy), dir(d) {}
	void move(double len) {
		x += len*cos(dir);
		y += len*sin(dir);
	}
	void setDir(double nd) { dir = nd; }
};

struct Bus : public Car, protected reg_znak { //производный класс, режим доступа к базовом классам
	//по умолчанию берется более строгий режим доступа (public Car при class Сar - будет private)
	//protected - доступ к полям и методом базового только из методов производного
	int people;
	double money;
	Bus(double xx, double yy, double d, int aa) :Car(xx, yy, d), reg_znak(aa), people(0), money(0) {} //использование функции от Car
	void move(double len) {
		Car::move(len); //использование функции от Car
		money += people*len;
	}
	void enter(int n) {
		if (n >= 0)
			people += n;
	}
	void exit(int n) {
		if (n >= 0)
			if (n >= people)
				people = 0;
			else
				people -= n;
	}
};

struct Employee { //полиморфическая структура
	virtual ~Employee() {} //виртуальные функции, работают как указатели 
	virtual double salary() = 0;
};

struct Manager : Employee {
	double salary(){ return 13000; }
};

struct Agent : Employee {
	double amount;
	Agent(double a) : amount(a) {}
	double salary(){ return 5000 + 0.05*amount;	}
};
struct Worker : Employee{
	double time;
	Worker(double t) : time(t) {}
	double salary(){ return 100 * time;	}
};


int main() {
	setlocale(LC_ALL, "Russian");
	Employee *M[9];
	M[0] = new Manager;
	M[1] = new Manager;
	M[2] = new Manager;
	M[3] = new Agent(100000);
	M[4] = new Agent(110000);
	M[5] = new Agent(120000);
	M[6] = new Worker(140);
	M[7] = new Worker(150);
	M[8] = new Worker(160);
	for (int i = 0; i < 9; i++) {
		cout << "Зарплата " << i << "-го сотрудника составляет " << M[i]->salary() << " р." << endl;
		delete M[i]; //проявление полиморфизма: одно и то же выражение для разных структур(в удалении и выводе)
	}
	system("pause");
	return 0;
}
