#include <iostream>

#include <stack>
#include <queue>
#include <vector>
#include <list> 
//шаблонные классы стэк, очередь, вектор, двусвязный список
#include <iterator> //работа с итераторами не связанными со стандартными классами

using namespace std;

template<class T, int s> //шаблонный класс
class Stack {
	T data[s];
	int c;
public:
	Stack() { c = 0; }
	void push(T x) {
		if (c<s)
			data[c++] = x;
	}
	T pop() {
		if (!empty())
			return data[--c];
		else return T();
	}
	bool empty() { return c == 0; }
};

template<> //частный случай шаблонного класса
class Stack<bool, 2> {
	/*тело класса для частного случая*/
};
//для ускорения работы программы во всех файлах, кроме одного, следует
//писать extern template class имя<параметры>

Stack<int, 10> S; //объявление

template<class T>
void print(list<T> l) {
	typename list<T>::iterator i; //объявление итератора
								  //typename, чтобы понять, что list<T>::iterator — тип
	for (i = l.begin(); i != l.end(); i++) //двунаправленные итераторы можно сравнивать только на == и !=
		cout << *i << endl; //разыменование
							//для структурных типов вместо * нужно писать ->
}

//Обобщение для любого стандартного контейнера с iterator
template<class T>
void print(T l)
{
	typename T::iterator i;
	for (i = l.begin(); i != l.end(); i++)
		cout << *i << endl;
}

//программирование на этапе компиляции
const int N = 5;
template<int n>
struct Fib{ enum { value = Fib<n - 1>::value + Fib<n - 2>::value }; };
template<>
struct Fib<1>{ enum { value = 1 }; };
template<>
struct Fib<2>{ enum { value = 1 }; };
int A00[Fib<N>::value];

//более удобный вариант
constexpr int fib(int n){ return n <= 2 ? 1 : fib(n - 1) + fib(n - 2); }
int A01[fib(N)];

int main() {

	system("pause");
	return 0;
}
