иерархия
классов для представления
программ и данных
виртуальной машины

1.1 Цель и ожидаемые результаты данного за-
дания
Цель выполнения данного задания — создание библиотеки для представле-
ния определенного вида деревьев в программе.
Способ решения — создание иерархии классов, представляющих нужные
нам деревья.

1.2 Описание нужных нам деревьев
Деревья, представление которых нам нужно (в дальнейшем будем называть
их объектами), определяются рекурсивно следующим образом.
1) Явно выписанные константы: специальная константа null, целые чис-
ла (произвольной разрядности), вещественные числа и строки являются
объектами.
2) Списки из объектов тоже являются объектами.

1.3 Интерфейс библиотеки
Библиотека предоставляет пользователю класс WSEML, объекты которого
представляют в программе нужные нам деревья.


Этот класс должен иметь следующие возможности:
1) Конструкторы:
1.1) по умолчанию (константа null)
1.2) по целому числу (целое число с заданным значением)
1.3) по вещественному числу (вещественное число с заданным значением)
1.4) по строке типа string (строка с заданным значением)
1.5) по списку инициализации с тем же типом элементов (список с заданным значением)
1.6) конструктор копирования (копия с той же структурой)
1.7) конструктор перемещения

2) Деструктор

3) Полный набор перегруженных операций сравнения (< > <= >= == !=)
для его объектов, по следующим правилам: любое целое число < лю-
бого вещественного < любой строки < любого списка, внутри одного типа
объектов естественный порядок (для целых чисел, для вещественных —
по величине, для строк — лексикографический посимвольно, для списков
— лексикографический поэлементно, для сравнения элементов списка ис-
пользуются те же правила).

4) Полный набор функций сравнения (функций, принимающих 2 объек-
та и возвращающих логическое значение) по слегка другим правилам (от-
личие — в том, что у целых и вещественных чисел естественный порядок
общий, например, 5==5.0 и 1<2.0<3). Имена этих функций должны быть
следующими:
cmd_lt <
cmd_gt >
cmd_le <=
cmd_ge >=
cmd_eq ==
cmd_neq !=

5) Операции для вычислений
5.1) Полный набор перегруженных арифметических, битовых и логиче-
ских операций, как в C (+ для строк и списков — конкатенация)
5.2) Операции преобразования к типам — long long int, long double, string
(если тип реального объекта не соответствует или его значение не влезает в
разрядную сетку, кидается исключение (все исключения имеют тот же тип
WSEML, и содержат строку с сообщением об ошибке)).
5.3) набор методов для конкретных типов объектов (если тип реального
объекта не соответствует, кидается исключение):
5.3.1) перегруженные операции инкремента и декремента для чисел
5.3.2) перегруженные арифметические и битовые операции, совмещен-
ные с присваиванием

6) Индексация (для объектов, являющихся списками или строками; для
остальных возбуждается исключение)
6.1) Операция индексации для списков (параметр — либо так называе-
мое выражение индексации, т. е. объект того же класса, являющийся спис
ком из двух элементов, первый из них — строка и второй — объект, либо
список из выражений индексации, в дальнейшем такие объекты мы будем
называть указателями; результат — ссылка на WSEML). Если параметр —
список выражений индексации, то первое из них означает выбор элемента
исходного списка, второе — выбор его элемента (выбранный первым выра-
жением индексации элемент исходного списка в этом случае и сам обязан
быть списком, и именно из него второе выражение индексации выбирает
элемент), и т. д. до элемента, выбранного из соответствующего списка по-
следним выражением индексации, ссылка на который и возвращается в ка-
честве результата. Первый элемент выражения индексации может иметь
следующие значения:
6.1.1) "i"(такое выражение индексации называется "по индексу"); в этом
случае второй объект должен быть целым числом. Это число трактуется
как индекс (неотрицательные значения с начала, отрицательные — с конца)
6.1.2) "id"(такое выражение индексации называется "по идентичности");
в этом случае второй объект тоже должен быть целым числом. Это число
трактуется как так называемая локальная идентичность элемента списка.
Она определяется как порядковый номер попадания указанного элемента
в список. Элемент, попавший в список первым, получает значение локаль-
ной идентичности, равное 1, попавший вторым — 2, и т. д., безотносительно
к тому, в каком порядке эти элементы идут в списке. Эта характеристи-
ка элемента в списке хороша тем, что сохраняется неизменной от момента
попадания элемента в список и до его удаления, независимо от изменений,
происходящих со списком, пока они не затрагивают этого конкретного эле-
мента.
6.1.3) "n"(такое выражение индексации называется "по имени"); в этом
случае второй объект (обозначим его x) может быть произвольным, и такая
операция индексации выбирает первый элемент списка, который сам
является списком, причем первый его элемент совпадает с x.
6.2) Перегруженная операция вызова функции (параметр — указатель,
результат имеет логический тип). Возвращает true, если объект — список,
и у него есть элемент, определяемый значением параметра по тем же правилам,
что и в операции индексации (см. п. 6.1).
6.3) Методы преобразования выражений индексации из одного вида (вид
выражения индексации определяется строкой, находящейся в его первом
элементе) в другой. Если в списке нет такого элемента, или преобразование
невозможно (например, мы хотим преобразовать выражение индексации к
виду "по имени но соответствующий элемент списка сам списком не является,
или до него есть другой элемент, тоже являющийся списком, с тем ж
первым элементом), кидается исключение.
6.3.1) to_index (параметр — выражение индексации, результат — выражение
индексации вида "по индексу выбирающее тот же самый элемент)
6.3.2) to_id (параметр — выражение индексации, результат — выраже-
ние индексации вида "по идентичности выбирающее тот же самый элемент)
6.3.3) to_name (параметр — выражение индексации, результат — выра-
жение индексации вида "по имени выбирающее тот же самый элемент)
6.4) для строк (параметр — целое число типа int; результат — ссылка на
char). При этом выбор элемента и символа в строке могут комбинироваться,
для чего в качестве индекса используется список, все элементы которого,
кроме последнего, являются выражениями индексации, а последний — объ-
ектом, содержащим целое число.

7) Метод type(), возвращающий реальный тип объекта (значение со-
ответствующего перечислимого типа — NULLOBJECT, INTEGER, REAL,
STRING, LIST)

8) Методы манипуляции со списками и строками:
8.1) size без параметров — размер (для строк — длина)
8.2) del — удаление элемента списка (параметр — выражение индекса-
ции для удаления одного элемента или еще число (типа int) удаляемых
элементов, начиная с того, который выбирается выражением индексации,
результата нет) или символа строки (параметр — индекс типа int, зада-
ющий удаляемый символ, и еще, возможно, число удаляемых элементов,
тоже типа int)
8.3) insert — вставка элементов (параметры — позиция, заданная выра-
жением индексации, и вставляемый элемент, для списков, или позиция типа
int и вставляемый символ типа char или строка типа string)
8.4) push_back — вставка в конец, параметр — объект для списков, сим-
вол типа char или строка типа string для строк
8.5) push_front — аналогично в начало
8.6) вложенный класс итератора, хранящий С-указатель (обычный ад-
рес типа WSEML *, не список из выражений индексации) на свой (пере-
бираемый) объект и локальную идентичность для указания позиции в нем
для списков, и индекс для строк, со всеми необходимыми операциями. Для
итератора, возвращаемого методом end,поле локальной идентичности со-
держит 0.
8.7) все обычные вложенные типы, которые должен иметь контейнер,
вроде value_type (всегда WSEML) и т. д.

9) операция присваивания

10) операции ввода из потока и вывода в поток. Для этого используется
текстовое представление объектов, которое и будет описано в этом разделе.
10.1) явная константа null представлена словом null
10.2) целые числа представлены строками из цифр без пробелов между
ними; перед первой цифрой возможен знак минус, не отделяющийся от нее
пробелами (цифр может быть сколько угодно).
10.3) вещественные числа представлены, как в C
10.4) строковые константы ограничиваются символами ‘ и ’. Внутри
строки скобки (круглые, квадратные и фигурные), а также открывающие
и закрывающие символы строки должны быть сбалансированы; при этом в
балансировке учитываются только те символы, которые не экранированы
стоящим перед ними бэкслешем.
10.5) списки ограничиваются квадратными скобками, и их элементы раз-
деляются запятыми; при этом пробельные символы между квадратными
скобками, отдельными элементами и запятыми игнорируются. Также внут-
ри списка на верхнем уровне допустимы комментарии, начинающиеся с //
и заканчивающиеся символом перевода строки, и вся эта конструкция иг-
норируется.
10.6) Заканчивается ввод либо концом файла, либо символом перевода
строки, не завершающим комментарий и не входящим в состав списка или
строковой константы.
10.7) Вывод происходит в том же формате (без комментариев и про-
бельных символов, за исключением перевода строки в самом конце), чтобы
выведенный объект можно было ввести потом обратно при помощи опера-
ции чтения.
10.8) Вложенный во WSEML класс iterator тоже нужно уметь вводить
и выводить для нужд отладки. Его текстовое представление — содержимое
адреса (целое 16-ричное число), затем знак $ и наконец, содержащаяся в
нем локальная идентичность (как десятичное целое число), причем вся эта
конструкция не должна содержать пробельных символов.
