import math

#функция
def f0(x):
	return 8 * math.cos(x) - x - 6

#1 производная
def f1(x):
	return -8 * math.sin(x) - 1

#2 производная
def f2(x):
	return -8 * math.cos(x)

#задание начальных данных
A = -9.0
B = 1.0
#эпсилон
E = 0.0000001
#количество отрезков в разбиении
N = 100
H = (B - A) / N
X1 = A
X2 = A + H
count = 0

print('Численные методы решения нелинейных уравнений' + '\n')
print('Начальные данные')
print('A = ' + str(A))
print('B = ' + str(B))
print('Функция: 8 * cos(x) - x - 6')
print('Погрешность = ' + str(E)  + '\n')

#отделение корней
#списки для хранения концов отрезков
print('Отделение корней')
Ai = []
Bi = []
for i in range(N):
	if(f0(X1) * f0(X2) <= 0):
		count += 1
		Ai.append(X1)
		Bi.append(X2)
	X1 += H
	X2 += H
for i in range(len(Ai)):
	print('[' + str(Ai[i]) + ', ' + str(Bi[i]) + ']')
print('Количество отрезков ' + str(count) + '\n')

#УТОЧНЕНИЕ КОРНЕЙ

#1)метод бисекции
def metod1(A, B):
	print('1)Метод бисекции')
	#список для хранения корней
	Xi = []
	#список для хранения длин отрезков
	delta_i = []
	#список для хранения количества шагов
	Ni = [0, 0, 0, 0]
	for i in range(len(A)):
		a = A[i]
		b = B[i]
		while(b - a > 2 * E):
			c = (a + b) / 2
			if(f0(a) * f0(c) <= 0):
				b = c
			else:
				a = c
			Ni[i] += 1
		Xi.append((a + b) / 2)
		delta_i.append((b - a) / 2)
	for i in range(len(A)):
		print('Начальное приближение ' + str(A[i]))
		print('Количество шагов ' + str(Ni[i]))
		print('Приближенное решение ' + str(Xi[i]))
		print('Длина отрезка ' + str(delta_i[i]))
		print('Абсолютная невязка ' + str(f0(Xi[i])) + '\n')

#2)метод Ньютона
def metod2(A, B):
	print('2)Метод Ньютона')
	#список для хранения корней
	Xi = []
	#два числа для вычислений
	a = 0.0
	b = 0.0
	#список для разницы двух последних приближений
	delta_i = []
	#список для хранения количества шагов
	Ni = [0, 0, 0, 0]
	for i in range(len(A)):
		a = A[i]
		b = a - f0(a)/f1(a)
		while(abs(b - a) >= E):
			a = b
			b = a - f0(a)/f1(a)
			Ni[i] += 1
		Xi.append(b)
		delta_i.append(abs(b - a))
	for i in range(len(A)):
		print('Начальное приближение ' + str(A[i]))
		print('Количество шагов ' + str(Ni[i]))
		print('Приближенное решение ' + str(Xi[i]))
		print('Модуль разности между двумя последними приближениями ' + str(delta_i[i]))
		print('Абсолютная невязка ' + str(f0(Xi[i])) + '\n')

#3)метод Ньютона модифицированный
def metod3(A, B):
	print('3)Метод Ньютона модифицированный')
	#список для хранения корней
	Xi = []
	#два числа для вычислений
	a = 0.0
	b = 0.0
	#список для разницы двух последних приближений
	delta_i = []
	#список для хранения количества шагов
	Ni = [0, 0, 0, 0]
	for i in range(len(A)):
		a = A[i]
		b = a - f0(a)/f1(A[i])
		while(abs(b - a) >= E):
			a = b
			b = a - f0(a)/f1(A[i])
			Ni[i] += 1
		Xi.append(b)
		delta_i.append(abs(b - a))
	for i in range(len(A)):
		print('Начальное приближение ' + str(A[i]))
		print('Количество шагов ' + str(Ni[i]))
		print('Приближенное решение ' + str(Xi[i]))
		print('Модуль разности между двумя последними приближениями ' + str(delta_i[i]))
		print('Абсолютная невязка ' + str(f0(Xi[i])) + '\n')

#4)метод секущих
def metod4(A, B):
	print('4)Метод секущих')
	#список для хранения корней
	Xi = []
	#три числа для вычислений
	a = 0.0
	b = 0.0
	c = 0.0
	#список для разницы двух последних приближений
	delta_i = []
	#список для хранения количества шагов
	Ni = [0, 0, 0, 0]
	for i in range(len(A)):
		a = A[i]
		b = B[i]
		c = b - f0(b)/(f0(b) - f0(a)) * (b - a) 
		while(abs(c - b) >= E):
			a = b
			b = c
			c = b - f0(b)/(f0(b) - f0(a)) * (b - a) 
			Ni[i] += 1
		Xi.append(c)
		delta_i.append(abs(c - b))
	for i in range(len(A)):
		print('Начальное приближение ' + str(A[i]))
		print('Количество шагов ' + str(Ni[i]))
		print('Приближенное решение ' + str(Xi[i]))
		print('Модуль разности между двумя последними приближениями ' + str(delta_i[i]))
		print('Абсолютная невязка ' + str(f0(Xi[i])) + '\n')
metod1(Ai, Bi)
metod2(Ai, Bi)
metod3(Ai, Bi)
metod4(Ai, Bi)
