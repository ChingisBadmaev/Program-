import random
import math
import matplotlib.pyplot as plt
import numpy as np

#АЛГОРИТМ А
#вероятность, что ток молнии не меньше данного
def probability(current_strength):
    return 1/(1 + (current_strength/31)**2.6)

#вычисление y_min_i
def y_min_i(height, current_strength):
    r_s_i = 10 * current_strength**0.65
    r_g_i = 0.9 * r_s_i
    if(height >= r_g_i):
        return r_s_i
    else: 
        return math.sqrt(r_s_i**2 - (r_g_i - height)**2)

#вычисление y_max_i
def y_max_i(CFO, height, current_strength):
    return 30 * (current_strength * height)/(1.5 * CFO) * (1 + (0.4/math.sqrt(2)) * (1/math.sqrt(0.92)))
#0.92 = 1 - 0.5 * 0.4**2

#вычисление количства перекрытий на 100 км за год (B)
def num_of_insulation_flashovers(CFO, height, N_g = 1):
    sum = 0.0
    i = 1
    while i <= 200:
        if(y_max_i(CFO, height, i) > y_min_i(height, i)):
            sum += (y_max_i(CFO, height, i) - y_min_i(height, i)) * (probability(i) - probability(i + 1))
        i += 1
    return 0.2 * sum * N_g

#A = []
#B = []
#print_schedule(10)
#scatterplot(A, B, "CFO", "Flashovers", "XY")
#plt.show()


#АЛГОРИТМ В
#коэффициент корреляции
p = 0.47
#медиана по силе тока
current_strength_mu = 31.1
#средне квадртичное отклонение по силе тока
current_strength_sigma = 0.484
#медиана по времени фронта
time_mu = 3.83
#средне квадратичное отклонение по времени фронта
time_sigma = 0.553
#список Z_n 
Z_n = []
#список U_n 
U_n = []
#список I_p_n 
I_p_n = []
#список t_f_n
t_f_n = []
#список y_n 
y_n = []

#вычисление I_p_n
def compute_I_p_n():
    Z_n.append(random.uniform(0, 1))
    I_p_n.append(math.exp(current_strength_mu + current_strength_sigma * Z_n[len(Z_n) - 1]))

#вычисление t_f_n
def compute_t_f_n():
    time_mu1 = time_mu + p * (time_sigma/current_strength_sigma) * (math.log(I_p_n[len(I_p_n) - 1]) - current_strength_mu) #time_mu*
    time_sigma1 = time_sigma * math.sqrt(1 - p**2) #time_sigma*
    Z_n.append(random.uniform(0, 1))
    t_f_n.append(math.exp(time_mu1 + time_sigma1 * Z_n[len(Z_n) - 1]))

#вычисление y_n
def compute_y_n(CFO, height):
    U_n.append(random.uniform(0, 1))
    y_n.append(U_n[len(U_n) - 1] * y_max_i(CFO, height, I_p_n[len(I_p_n) - 1]))

#100 молний
def create_lightn():
    t = 0
    while t < 100:
        compute_I_p_n()
        compute_t_f_n()
        #compute_y_n(CFO, height)
        t += 1

#вычисление количства перекрытий на 100 км за год
def num_of_insulation_flashovers_B(CFO, height, N_g = 1):
    sum = 0.0
    i = 0
    while i < 100:
        if(y_max_i(CFO, height, I_p_n[i]) > y_min_i(height, I_p_n[i])):
            sum += (y_max_i(CFO, height, I_p_n[i]) - y_min_i(height, I_p_n[i])) * (probability(I_p_n[i]) - probability(I_p_n[i] + 1))
        i += 1
    return 0.2 * sum * N_g

#график
def scatterplot(x_data, y_data, x_label="", y_label="", title="", color = "r", yscale_log=False):
    # Create the plot object
    _, ax = plt.subplots()

    # Plot the best fit line, set the linewidth (lw), color and
    # transparency (alpha) of the line
    i = 0
    while i < 11:
        ax.scatter(x_data[i], y_data[i], s = 10, color = color, alpha = 0.75)
        i += 1

    # Label the axes and provide a title
    ax.set_title(title)
    ax.set_xlabel(x_label)
    ax.set_ylabel(y_label)

#вывод графика
def print_schedule(height):
    i = 50
    str1 = ""
    while i <= 300:
        A.append(i)
        B.append(num_of_insulation_flashovers_B(i, height))
        i += 25


A = []
B = []
create_lightn()
print_schedule(10)
scatterplot(A, B, "CFO", "Flashovers", "XY")
plt.show()CFO", "Flashovers", "XY")
plt.show()
