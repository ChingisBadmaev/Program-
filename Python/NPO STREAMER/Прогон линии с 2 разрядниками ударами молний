import random
import math
import numpy as np

# ЛЭП
class PowerLine:
    # DLS - direct lightning strike 
    arrester_DLS = []
    # RO - reverse overlap
    arrester_RO = []
    def __init__(obj, num_tower):
        obj.arrester_DLS = [0 for i in range(num_tower)]
        obj.arrester_RO = [0 for i in range(num_tower)]

# Медиана по силе тока
CUR_STR_MEDIAN = 31
# Средне квадртичное отклонение по силе тока
CUR_STR_SIGMA = 0.605

# Плотность логнормального распределения
def p_lognorm(value, median, sigma):
    a1 = 1 / (math.sqrt(2 * math.pi) * value * sigma)
    a2 = math.exp(-(math.log(value) - math.log(median)) ** 2 / (2 * sigma ** 2)) 
    return a1 * a2

# Нахождение медианного значения
def mod_p(median, sigma):
    return math.exp(math.log(median) - sigma ** 2)

# Максимум плотности для тока молнии
def max_p_i():
    return p_lognorm(mod_p(CUR_STR_MEDIAN, CUR_STR_SIGMA), CUR_STR_MEDIAN, CUR_STR_SIGMA)

# Создание I_p_n (череды сил тока)
def create_I_p_n(N_tot=100):
    I_p_n = []
    for i in range(N_tot):
        I_p = 1 + (200 - 1) * random.uniform(0, 1)
        Z = random.uniform(0, 1)
        while Z >= p_lognorm(I_p, CUR_STR_MEDIAN, CUR_STR_SIGMA) / max_p_i():
            I_p = 1 + (200 - 1) * random.uniform(0, 1)
            Z = random.uniform(0, 1)
        I_p_n.append(I_p)
    return I_p_n

# Проверка на перегрузку DLS разрядников при ударе в опору 
def check_tower_DLS(cur_str, ind_tower):
    if(ind_tower == 0):
        if(cur_str < 40): return cur_str * 0.68
        else: return cur_str * 0.8
    if(ind_tower == 1):
        if(cur_str < 30): return cur_str * 0.22
        else: return cur_str * 0.13
    if(ind_tower == 2):
        return cur_str * 0.05

# Проверка на перегрузку RO разрядников при ударе в опору 
def check_tower_RO(cur_str, ind_tower):
    if(ind_tower == 0):
        if(cur_str < 50): return cur_str * 0.2
        else: return cur_str * 0.25
    if(ind_tower == 1):
        return cur_str * 0.06
    if(ind_tower == 2):
        return cur_str * 0.05

# Проверка на перегрузку DLS разрядников 
# при ударе в середину пролета 
def check_span_DLS(cur_str, ind_tower):
    if(ind_tower == 1):
        if(cur_str < 40): return cur_str * 0.44
        else: return cur_str * 0.4
    if(ind_tower == 2):
        if(cur_str < 30): return cur_str * 0.17
        else: return cur_str * 0.11
    if(ind_tower == 3):
        return cur_str * 0.05

# Проверка на перегрузку RO разрядников 
# при ударе в середину пролета 
def check_span_RO(cur_str, ind_tower):
    if(ind_tower == 1):
        return cur_str * 0.09
    if(ind_tower == 2):
        return cur_str * 0.05
    if(ind_tower == 3):
        return cur_str * 0.04

# Вычисление результата удара молнии в середину пролета
def comp_lightn_strike_span(power_line, cur_str, num_span):
    for i in range(3):
        if(num_span - 3 + i >= 0):
            power_line.arrester_DLS[num_span - 3 + i] += 1
            power_line.arrester_RO[num_span - 3 + i] += 1
            if(power_line.arrester_DLS[num_span - 3 + i] != int(power_line.arrester_DLS[num_span - 3 + i])):
                continue
            if(power_line.arrester_RO[num_span - 3 + i] != int(power_line.arrester_RO[num_span - 3 + i])):
                continue
            if(check_span_DLS(cur_str, 3 - i) >= 20):
                power_line.arrester_DLS[num_span - 3 + i] += power_line.arrester_DLS[num_span - 3 + i] / 10
            if(check_span_RO(cur_str, 3 - i) >= 20):
                power_line.arrester_RO[num_span - 3 + i] += power_line.arrester_RO[num_span - 3 + i] / 10
    for i in range(3):
        if(num_span + i < len(power_line.arrester_DLS)):
            power_line.arrester_DLS[num_span + i] += 1
            power_line.arrester_RO[num_span + i] += 1
            if(power_line.arrester_DLS[num_span + i] != int(power_line.arrester_DLS[num_span + i])):
                continue
            if(power_line.arrester_RO[num_span + i] != int(power_line.arrester_RO[num_span + i])):
                continue
            if(check_span_DLS(cur_str, i + 1) >= 20):
                power_line.arrester_DLS[num_span + i] += power_line.arrester_DLS[num_span + i] / 10
            if(check_span_RO(cur_str, i + 1) >= 20):
                power_line.arrester_RO[num_span + i] += power_line.arrester_RO[num_span + i] / 10

# Вычисление результата удара молнии в опору
def comp_lightn_strike_tower(power_line, cur_str, num_span):
    for i in range(2):
        if(num_span - 2 + i >= 0):
            power_line.arrester_DLS[num_span - 2 + i] += 1
            power_line.arrester_RO[num_span - 2 + i] += 1
            if(power_line.arrester_DLS[num_span - 2 + i] != int(power_line.arrester_DLS[num_span - 2 + i])):
                continue
            if(power_line.arrester_RO[num_span - 2 + i] != int(power_line.arrester_RO[num_span - 2 + i])):
                continue
            if(check_tower_DLS(cur_str, 2 - i) >= 20):
                power_line.arrester_DLS[num_span - 2 + i] += power_line.arrester_DLS[num_span - 2 + i] / 10
            if(check_tower_RO(cur_str, 2 - i) >= 20):
                power_line.arrester_RO[num_span - 2 + i] += power_line.arrester_RO[num_span - 2 + i] / 10
    for i in range(3):
        if(num_span + i < len(power_line.arrester_DLS)):
            power_line.arrester_DLS[num_span + i] += 1
            power_line.arrester_RO[num_span + i] += 1
            if(power_line.arrester_DLS[num_span + i] != int(power_line.arrester_DLS[num_span + i])):
                continue
            if(power_line.arrester_RO[num_span + i] != int(power_line.arrester_RO[num_span + i])):
                continue
            if(check_tower_DLS(cur_str, i) >= 20):
                power_line.arrester_DLS[num_span + i] += power_line.arrester_DLS[num_span + i] / 10
            if(check_tower_RO(cur_str, i) >= 20):
                power_line.arrester_RO[num_span + i] += power_line.arrester_RO[num_span + i] / 10

# Вычисление результата череды событий
def comp_ans(power_line, N_tot=100):
    I_p_n = create_I_p_n(N_tot)
    ind_span = np.random.permutation(N_tot)
    for i in range(N_tot):
        k = random.randint(0, 1)
        if(k == 1):
            comp_lightn_strike_span(power_line, I_p_n[i], ind_span[i])
        else:
            comp_lightn_strike_tower(power_line, I_p_n[i], ind_span[i])

# Вывод результата череды событий
def print_ans(power_line):
    comp_ans(power_line)
    tot_posit = 0
    tot_flashovers = 0
    for i in range(len(power_line.arrester_DLS)):
        tot_posit += int(power_line.arrester_DLS[i])
        if(power_line.arrester_DLS[i] == int(power_line.arrester_DLS[i])):
            tot_flashovers += int(power_line.arrester_DLS[i]) 
            - (power_line.arrester_DLS[i] - int(power_line.arrester_DLS[i])) * 10
    
    print('Количество срабатываний разрядников ' + str(tot_posit))
    print('Количество негашений ' + str(tot_flashovers))

def main():
    power_line = PowerLine(101)
    print_ans(power_line)
    print(power_line.arrester_DLS)
    print(power_line.arrester_RO)

if __name__ == '__main__':
    main()
