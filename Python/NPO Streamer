import random
import math

#молния
class lightn:
    dist = 0.0 #метры
    time = 0.0 #микросекунды
    strength = 0.0 #килоамперы
    def __init__(obj, dist, time, strength):
        obj.dist = dist
        obj.time = time
        obj.strength = strength

#линия
class line: 
    CFO = 0.0 #киловольты
    height = 0.0 #метры
    number_of_phases = 0 #без единиц
    def __init__(obj, CFO, height, number_of_phases):
       obj.CFO = CFO
       obj.height = height
       obj.number_of_phases = number_of_phases
 
#ввод молний
array_lightn = [] #список молний
#заполнение случайным значениями
i = 0
while i < 5:
    array_lightn.append(lightn(random.uniform(1, 10), random.uniform(1, 10), random.uniform(1, 200))) 
    i += 1

i = 0
while i < 5:
    print(array_lightn[i].dist)
    print(array_lightn[i].time)
    print(array_lightn[i].strength)
    print()
    i += 1

#вероятность, что ток молнии не меньше данного
def probability(current_strength):
    return 1/(1 + (current_strength/31)**2.6)

#вычисление y_min_i
def y_min_i(height, num_i):
    r_s_i = 10 * num_i**0.65
    r_g_i = 0.9 * r_s_i
    if(height >= r_g_i):
        return r_s_i
    else: 
        return math.sqrt(r_s_i**2 - (r_g_i - height)**2)

#вычисление y_max_i
def y_max_i(CFO, height, num_i):
    return 30 * (num_i * height)/(1.5 * CFO) * (1 + (0.4/math.sqrt(2))*(1/math.sqrt(0.92)))
#0.92 = 1 - 0.5 * 0.4**2

#вычисление количства перекрытий на 100 км за год
def num_of_insulation_flashovers(CFO, height, N_g = 1):
    sum = 0.0
    i = 1
    while i <= 200:
        sum += (y_max_i(CFO, height, i) - y_min_i(height, i)) * (probability(i) - probability(i + 1))
        i += 1
    return 0.2 * sum * N_g

print(probability(201))
print(y_min_i(10, 50))
print(y_max_i(100, 10, 50))
print(num_of_insulation_flashovers(100, 10))
